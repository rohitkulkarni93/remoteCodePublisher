//////////////////////////////////////////////////////////////////////
// CodePublisher - Package publishes static code files				//
// Ver 1.0															//
// Application: Dependency based Code Publisher						//
// Platform:    Lenovo Z580, Win 10 Pro, Visual Studio 2017 RC 1	//
// Author:      Kulkarni Rohit,										//
//              rvkulkar@syr.edu									//
//////////////////////////////////////////////////////////////////////
#include "CodePublisher.h"
#include "StrHelper.h"
#include "../XmlDocument/XmlDocument.h"
#include "../FileSystem/FileSystem.h"
#include "HTMLGenerator.h"
#include <Windows.h>

using namespace FileSystem;

//	Publish html files
void CodePublisher::publishCode(string path, string outputPath,
	vector<string> patterns)
{
	this->publishPath = outputPath;
	if (!FileSystem::Directory::exists(path))
	{
		cout << "Analysis path doesn't exist: " << path;
		return;
	}
	string directory = FileSystem::Directory::getCurrentDirectory();
	FileSystem::Directory::setCurrentDirectory(publishPath);
	generator.generateCSSFile();
	generator.generateJavascriptFile();
	FileSystem::Directory::setCurrentDirectory(directory);
	processDirectory(path, patterns);
	cout << "Code publishing complete." << endl;
}

//	Process each file
void CodePublisher::processFiles(vector<string> files)
{
	for each (string fileName in files)
	{
		string convertedSourceCode = makeReplacements(fileName);
		this->generateHtmlFile(fileName, convertedSourceCode);
	}
}

//	get correct directory name
string CodePublisher::getDirectoryName(string base, string currentDirectory)
{
	string dirName = "";
	if (base.size() > 0 && currentDirectory.size() > 0) {
		if (base[base.length() - 2] == '\\' && base[base.length() - 3] == '\\')
			dirName = base + currentDirectory;
		else
			dirName = base + "\\\\" + currentDirectory;
	}
	return dirName;
}

//	Process directory recursively
void CodePublisher::processDirectory(string path, vector<string> patterns)
{
	using namespace std;
	try {
		FileSystem::Directory::setCurrentDirectory(path);
		for (string pattern : patterns) {
			processFiles(FileSystem::Directory::getFiles(".", pattern));
		}
		auto directories = FileSystem::Directory::getDirectories();
		for each (string dir in directories) {
			if (!(dir.compare(".") == 0 || dir.compare("..") == 0)) {
				processDirectory(getDirectoryName(path, dir), patterns);
			}
		}
	}
	catch (std::exception ex) {
		cout << "Exception" << ex.what();
	}
}

//	Configure the html generator
void CodePublisher::configure(Config config)
{
	generator(config);
}

//	Make necessary replacements in source file
string CodePublisher::makeReplacements(string file)
{
	ifstream fileReader(file, ios::in);
	string data = "";
	char c;
	if (fileReader.is_open()) {
		char c;
		while (fileReader.good()) {
			c = fileReader.get();
			if(c > -1 && c < 255)
				data += c;
		}
		fileReader.close();
	}
	size_t position = -1;
	do {
		position = data.find('<');
		if (position != string::npos) {
			data = data.replace(position, 1, "&lt");
		}
	} while (position != string::npos);
	do {
		position = data.find('>');
		if (position != string::npos) {
			data = data.replace(position, 1, "&gt");
		}
	} while (position != string::npos);

	return data;
}

//	Generate html file
void CodePublisher::generateHtmlFile(string fileName, string convertedSourceCode)
{
	string currentDirectory = FileSystem::Directory::getCurrentDirectory();
	FileSystem::Directory::setCurrentDirectory(this->publishPath);
	string xtension = ".html";
	string htmlPage = this->generator.createHtmlPage(fileName, convertedSourceCode, this->dependencies);
	ofstream fileWriter(fileName + xtension, ios::out);
	fileWriter.write(htmlPage.c_str(), htmlPage.length());
	fileWriter.close();
	FileSystem::Directory::setCurrentDirectory(currentDirectory);
}

CodePublisher::CodePublisher()
{

}

void CodePublisher::publishWebpage(string pagename)
{
	if (pagename != "")
	{
		pagename = publishPath + "\\" + pagename;
		if (FileSystem::File::exists(pagename)) {
			const char * file = pagename.c_str();
			ShellExecute(NULL, "open", file, NULL, NULL, SW_SHOWNORMAL);
		}
		else {
			cout << "File not found." << endl;
		}
	}
}

//	Import dependencies from analysis file generated by 
void CodePublisher::importDependencies(const unordered_map<string, vector<string>> & deps) {
	this->dependencies = deps;
}

//	Import dependencies from analysis file generated by Dependency Analyzer
unordered_map<string, vector<string>> CodePublisher::importDependenciesFromFile(string fileName)
{
	using namespace XmlProcessing;
	using SPtr = shared_ptr<AbstractXmlElement>;
	unordered_map<string, vector<string>> dependencies;
	if (FileSystem::File::exists(fileName))
	{
		XmlDocument doc(fileName, XmlDocument::file);
		std::vector<SPtr> desc = doc.element("DependencyAnalysis").select();
		for (auto dependency : desc[0]->children()) {
			string fileName = trim(dependency->children()[0]->children()[0]->value());
			vector<string> deps;
			for (auto depFile : dependency->children()[1]->children())
				deps.push_back(trim(depFile->children()[0]->value()));
			dependencies[fileName] = deps;
		}
	}
	this->dependencies = dependencies;
	return dependencies;
}

//----------------------------TEST STUB-------------------------------------
//	Uncomment the following code to test CodePublisher package
//int main()
//{
//	CodePublisher codePublisher;
//	Config config;
//	config.cssFileName = "style";
//	config.jsFileName = "javascript.js";
//	codePublisher.configure(config);
//	codePublisher.importDependencies("output.txt");
//	vector<string> patterns; 
//	patterns.push_back("*.cpp");
//	patterns.push_back("*.cpp");
//	codePublisher.publishCode(".\\RandomPathTest\\project1", "C:\outputFolder", patterns);
//}