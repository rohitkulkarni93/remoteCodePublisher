<!DOCTYPE html>
<html>
<head>
<script type="text/javascript" src="javascript.js"></script>
<link rel="stylesheet" href="style.css"></link>
</head>

<body>
<div id="dependencies">
<h3>
Dependencies</h3>
</div>
<pre>
/////////////////////////////////////////////////////////////////////
// Executive.cpp - Directs Code Analysis                           //
// ver 1.4                                                         //
//-----------------------------------------------------------------//
// Jim Fawcett (c) copyright 2016                                  //
// All rights granted provided this copyright notice is retained   //
//-----------------------------------------------------------------//
// Language:    C++, Visual Studio 2015                            //
// Platform:    Dell XPS 8900, Windows 10                          //
// Application: Project #2, CSE687 - Object Oriented Design, S2015 //
// Author:      Jim Fawcett, Syracuse University, CST 4-187        //
//              jfawcett@twcny.rr.com                              //
/////////////////////////////////////////////////////////////////////

#include "Executive.h"
#include &ltsstream&gt
#include &ltstring&gt
#include &ltvector&gt
#include &ltmap&gt
#include &ltunordered_map&gt
#include &ltfunctional&gt
#include &ltalgorithm&gt
#include &ltexception&gt
#include &ltiomanip&gt
#include &ltchrono&gt
#include &ltctime&gt

#include "../Parser/Parser.h"
#include "../FileSystem/FileSystem.h"
#include "../FileMgr/FileMgr.h"
#include "../Parser/ActionsAndRules.h"
#include "../Parser/ConfigureParser.h"
#include "../AbstractSyntaxTree/AbstrSynTree.h"
#include "../Logger/Logger.h"
#include "../Utilities/Utilities.h"
#include "TypeAnalysis.h"
#include "TestExecutive.h"
#include "Display.h"

using Rslt = Logging::StaticLogger&lt0&gt;  // use for application results
using Demo = Logging::StaticLogger&lt1&gt;  // use for demonstrations of processing
using Dbug = Logging::StaticLogger&lt2&gt;  // use for debug output


/////////////////////////////////////////////////////////////////////
// AnalFileMgr class
// - Derives from FileMgr to make application specific file handler
//   by overriding FileMgr::file(), FileMgr::dir(), and FileMgr::done()

using Path = std::string;
using File = std::string;
using Files = std::vector&ltFile&gt;
using Pattern = std::string;
using Ext = std::string;
using FileMap = std::unordered_map&ltPattern, Files&gt;

using namespace CodeAnalysis;

//----&lt initialize application specific FileMgr &gt--------------------
/*
 * - Accepts CodeAnalysisExecutive's path and fileMap by reference
 */
AnalFileMgr::AnalFileMgr(const Path& path, FileMap& fileMap)
	: FileMgr(path), fileMap_(fileMap), numFiles_(0), numDirs_(0) </pre><button class="button-expcol" onclick="showHideSection('span0')">{</button><div id="span0" style = "display: inline"><pre></pre></div><pre>}

//----&lt override of FileMgr::file(...) to store found files &gt------

void AnalFileMgr::file(const File& f)
</pre><button class="button-expcol" onclick="showHideSection('span1')">{</button><div id="span1" style = "display: inline"><pre>
	File fqf = d_ + "\\" + f;
	Ext ext = FileSystem::Path::getExt(fqf);
	Pattern p = "*." + ext;
	fileMap_[p].push_back(fqf);
	++numFiles_;
</pre></div><pre>}
//----&lt override of FileMgr::dir(...) to save current dir &gt----------

void AnalFileMgr::dir(const Dir& d)
</pre><button class="button-expcol" onclick="showHideSection('span2')">{</button><div id="span2" style = "display: inline"><pre>
	d_ = d;
	++numDirs_;
</pre></div><pre>}
//----&lt override of FileMgr::done(), not currently used &gt------------

void AnalFileMgr::done()
</pre><button class="button-expcol" onclick="showHideSection('span3')">{</button><div id="span3" style = "display: inline"><pre>
</pre></div><pre>}
//----&lt returns number of matched files from search &gt----------------

size_t AnalFileMgr::numFiles()
</pre><button class="button-expcol" onclick="showHideSection('span4')">{</button><div id="span4" style = "display: inline"><pre>
	return numFiles_;
</pre></div><pre>}
//----&lt returns number of dirs searched &gt----------------------------

size_t AnalFileMgr::numDirs()
</pre><button class="button-expcol" onclick="showHideSection('span5')">{</button><div id="span5" style = "display: inline"><pre>
	return numDirs_;
</pre></div><pre>}

/////////////////////////////////////////////////////////////////////
// CodeAnalysisExecutive class
// - 
using Path = std::string;
using Pattern = std::string;
using Patterns = std::vector&ltPattern&gt;
using File = std::string;
using Files = std::vector&ltFile&gt;
using Ext = std::string;
using FileMap = std::unordered_map&ltPattern, Files&gt;
using ASTNodes = std::vector&ltASTNode*&gt;
using FileToNodeCollection = std::vector&ltstd::pair&ltFile, ASTNode*&gt&gt;

//----&lt initialize parser, get access to repository &gt----------------

CodeAnalysisExecutive::CodeAnalysisExecutive()
</pre><button class="button-expcol" onclick="showHideSection('span6')">{</button><div id="span6" style = "display: inline"><pre>
	pParser_ = configure_.Build();
	if (pParser_ == nullptr)
	</pre><button class="button-expcol" onclick="showHideSection('span7')">{</button><div id="span7" style = "display: inline"><pre>
		throw std::exception("couldn't create parser");
	</pre></div><pre>}
	pRepo_ = Repository::getInstance();
</pre></div><pre>}
//----&lt cleanup &gt----------------------------------------------------

CodeAnalysisExecutive::~CodeAnalysisExecutive()
</pre><button class="button-expcol" onclick="showHideSection('span8')">{</button><div id="span8" style = "display: inline"><pre>
	/*
	 *  Nothing to do:
	 *  - pParser_ and pRepo_ point to objects that the configure_
	 *    destructor will delete.
	 *  - The AbstractSynTree object will cleanup its contents when
	 *    it goes out of scope by deleting the root of the AST node
	 *    tree.
	 *  - Each node deletes its children, so, again, nothing more
	 *    to do.
	 *  - This is here to present these comments and to make this
	 *    base destructor virtual.
	 */
</pre></div><pre>}
//----&lt usage message &gt----------------------------------------------

void showUsage()
</pre><button class="button-expcol" onclick="showHideSection('span9')">{</button><div id="span9" style = "display: inline"><pre>
	std::ostringstream out;
	out &lt&lt "\n  Usage:";
	out &lt&lt "\n  Command Line Arguments are:";
	out &lt&lt "\n  - 1st: path to subdirectory containing files to analyze";
	out &lt&lt "\n  - remaining non-option arguments are file patterns, e.g., *.h and/or *.cpp, etc.";
	out &lt&lt "\n  - must have at least one file pattern to specify what to process";
	out &lt&lt "\n  - option arguments have the format \"\"/x\" , where x is one of the options:";
	out &lt&lt "\n    - m : display function metrics";
	out &lt&lt "\n    - s : display file sizes";
	out &lt&lt "\n    - a : display Abstract Syntax Tree";
	out &lt&lt "\n    - r : set logger to display results";
	out &lt&lt "\n    - d : set logger to display demo outputs";
	out &lt&lt "\n    - b : set logger to display debug outputs";
	out &lt&lt "\n    - f : write all logs to logfile.txt";
	out &lt&lt "\n	- s [FILENAME] : write data to file - FILENAME";
	out &lt&lt "\n  A metrics summary is always shown, independent of any options used or not used";
	out &lt&lt "\n\n";
	std::cout &lt&lt out.str();
	//Rslt::write(out.str());
	//Rslt::flush();
</pre></div><pre>}
//----&lt show command line arguments &gt--------------------------------

void CodeAnalysisExecutive::showCommandLineArguments(int argc, char* argv[])
</pre><button class="button-expcol" onclick="showHideSection('span10')">{</button><div id="span10" style = "display: inline"><pre>
	std::ostringstream out;
	out &lt&lt "\n     Path: \"" &lt&lt FileSystem::Path::getFullFileSpec(argv[1]) &lt&lt "\"\n     Args: ";
	for (int i = 2; i &lt argc - 1; ++i)
		out &lt&lt argv[i] &lt&lt ", ";
	out &lt&lt argv[argc - 1];
	Rslt::write(out.str());
	Rslt::flush();
</pre></div><pre>}
//----&lt handle command line arguments &gt------------------------------
/*
* Arguments are:
* - path: possibly relative path to folder containing all analyzed code,
*   e.g., may be anywhere in the directory tree rooted at that path
* - patterns: one or more file patterns of the form *.h, *.cpp, and *.cs
* - options: /m (show metrics), /s (show file sizes), and /a (show AST)
*/
bool CodeAnalysisExecutive::ProcessCommandLine(int argc, char* argv[])
</pre><button class="button-expcol" onclick="showHideSection('span11')">{</button><div id="span11" style = "display: inline"><pre>
	if (argc &lt 2)
	</pre><button class="button-expcol" onclick="showHideSection('span12')">{</button><div id="span12" style = "display: inline"><pre>
		showUsage();
		return false;
	</pre></div><pre>}
	try </pre><button class="button-expcol" onclick="showHideSection('span13')">{</button><div id="span13" style = "display: inline"><pre>
		path_ = FileSystem::Path::getFullFileSpec(argv[1]);
		if (!FileSystem::Directory::exists(path_))
		</pre><button class="button-expcol" onclick="showHideSection('span14')">{</button><div id="span14" style = "display: inline"><pre>
			std::cout &lt&lt "\n\n  path \"" &lt&lt path_ &lt&lt "\" does not exist\n\n";
			return false;
		</pre></div><pre>}
		for (int i = 2; i &lt argc; ++i)
		</pre><button class="button-expcol" onclick="showHideSection('span15')">{</button><div id="span15" style = "display: inline"><pre>
			if (argv[i][0] == '/')
			</pre><button class="button-expcol" onclick="showHideSection('span16')">{</button><div id="span16" style = "display: inline"><pre>
				options_.push_back(argv[i][1]);
				if (argv[i][1] == 's') </pre><button class="button-expcol" onclick="showHideSection('span17')">{</button><div id="span17" style = "display: inline"><pre>
					bool b = setXMLPath(argv[i + 1]);
					if (b) </pre><button class="button-expcol" onclick="showHideSection('span18')">{</button><div id="span18" style = "display: inline"><pre>
						i++;
					</pre></div><pre>}
					else
					</pre><button class="button-expcol" onclick="showHideSection('span19')">{</button><div id="span19" style = "display: inline"><pre>
						showUsage();
						return false;
					</pre></div><pre>}
				</pre></div><pre>}
			</pre></div><pre>}
			else
				patterns_.push_back(argv[i]);
		</pre></div><pre>}
		if (patterns_.size() == 0)
		</pre><button class="button-expcol" onclick="showHideSection('span20')">{</button><div id="span20" style = "display: inline"><pre>
			showUsage();
			return false;
		</pre></div><pre>}
	</pre></div><pre>}
	catch (std::exception& ex)
	</pre><button class="button-expcol" onclick="showHideSection('span21')">{</button><div id="span21" style = "display: inline"><pre>
		std::cout &lt&lt "\n\n  command line argument parsing error:";
		std::cout &lt&lt "\n  " &lt&lt ex.what() &lt&lt "\n\n";
		return false;
	</pre></div><pre>}
	return true;
</pre></div><pre>}
//----&lt returns path entered on command line &gt-------------------

bool CodeAnalysisExecutive::setXMLPath(char * path) </pre><button class="button-expcol" onclick="showHideSection('span22')">{</button><div id="span22" style = "display: inline"><pre>
	bool validPath = true;
	if (path) </pre><button class="button-expcol" onclick="showHideSection('span23')">{</button><div id="span23" style = "display: inline"><pre>
		int i = 0;
		while (path[i] != '\0') </pre><button class="button-expcol" onclick="showHideSection('span24')">{</button><div id="span24" style = "display: inline"><pre>
			if (path[i] == '/') </pre><button class="button-expcol" onclick="showHideSection('span25')">{</button><div id="span25" style = "display: inline"><pre>
				validPath = false;
				break;
			</pre></div><pre>}
			i++;
		</pre></div><pre>}
		if (validPath) </pre><button class="button-expcol" onclick="showHideSection('span26')">{</button><div id="span26" style = "display: inline"><pre>
			this-&gtxmlFilePath = path;
		</pre></div><pre>}
	</pre></div><pre>}
	return validPath;
</pre></div><pre>}

std::string CodeAnalysisExecutive::getXMLPath()
</pre><button class="button-expcol" onclick="showHideSection('span27')">{</button><div id="span27" style = "display: inline"><pre>
	return xmlFilePath;
</pre></div><pre>}

std::string CodeAnalysisExecutive::getAnalysisPath()
</pre><button class="button-expcol" onclick="showHideSection('span28')">{</button><div id="span28" style = "display: inline"><pre>
	return path_;
</pre></div><pre>}
//----&lt returns reference to FileMap &gt---------------------------
/*
 * Supports quickly finding all the files found with a give pattern
 */
FileMap& CodeAnalysisExecutive::getFileMap()
</pre><button class="button-expcol" onclick="showHideSection('span29')">{</button><div id="span29" style = "display: inline"><pre>
	return fileMap_;
</pre></div><pre>}
//----&lt searches path for files matching specified patterns &gt----
/*
 * - Searches entire diretory tree rooted at path_, evaluated
 *   from a command line argument.
 * - Saves found files in FileMap.
 */
void CodeAnalysisExecutive::getSourceFiles()
</pre><button class="button-expcol" onclick="showHideSection('span30')">{</button><div id="span30" style = "display: inline"><pre>
	AnalFileMgr fm(path_, fileMap_);
	for (auto patt : patterns_)
		fm.addPattern(patt);
	fm.search();
	numFiles_ = fm.numFiles();
	numDirs_ = fm.numDirs();
</pre></div><pre>}
//----&lt helper: is text a substring of str? &gt--------------------

bool contains(const std::string& str, const std::string& text)
</pre><button class="button-expcol" onclick="showHideSection('span31')">{</button><div id="span31" style = "display: inline"><pre>
	if (str.find(text) &lt str.length())
		return true;
	return false;
</pre></div><pre>}
//----&lt retrieve from fileMap all files matching *.h &gt-----------

std::vector&ltFile&gt& CodeAnalysisExecutive::cppHeaderFiles()
</pre><button class="button-expcol" onclick="showHideSection('span32')">{</button><div id="span32" style = "display: inline"><pre>
	cppHeaderFiles_.clear();
	for (auto item : fileMap_)
	</pre><button class="button-expcol" onclick="showHideSection('span33')">{</button><div id="span33" style = "display: inline"><pre>
		if (contains(item.first, "*.h"))
		</pre><button class="button-expcol" onclick="showHideSection('span34')">{</button><div id="span34" style = "display: inline"><pre>
			for (auto file : item.second)
				cppHeaderFiles_.push_back(file);
		</pre></div><pre>}
	</pre></div><pre>}
	return cppHeaderFiles_;
</pre></div><pre>}
//----&lt retrieve from fileMap all files matching *.cpp &gt---------

std::vector&ltFile&gt& CodeAnalysisExecutive::cppImplemFiles()
</pre><button class="button-expcol" onclick="showHideSection('span35')">{</button><div id="span35" style = "display: inline"><pre>
	cppImplemFiles_.clear();
	for (auto item : fileMap_)
	</pre><button class="button-expcol" onclick="showHideSection('span36')">{</button><div id="span36" style = "display: inline"><pre>
		if (contains(item.first, "*.cpp"))
		</pre><button class="button-expcol" onclick="showHideSection('span37')">{</button><div id="span37" style = "display: inline"><pre>
			for (auto file : item.second)
				cppImplemFiles_.push_back(file);
		</pre></div><pre>}
	</pre></div><pre>}
	return cppImplemFiles_;
</pre></div><pre>}
//----&lt retrieve from fileMap all files matching *.cs &gt----------

std::vector&ltFile&gt& CodeAnalysisExecutive::csharpFiles()
</pre><button class="button-expcol" onclick="showHideSection('span38')">{</button><div id="span38" style = "display: inline"><pre>
	csharpFiles_.clear();
	for (auto item : fileMap_)
	</pre><button class="button-expcol" onclick="showHideSection('span39')">{</button><div id="span39" style = "display: inline"><pre>
		if (contains(item.first, "*.cs"))
		</pre><button class="button-expcol" onclick="showHideSection('span40')">{</button><div id="span40" style = "display: inline"><pre>
			for (auto file : item.second)
				csharpFiles_.push_back(file);
		</pre></div><pre>}
	</pre></div><pre>}
	return csharpFiles_;
</pre></div><pre>}
//----&lt report number of Source Lines Of Code (SLOCs) &gt----------

CodeAnalysisExecutive::Slocs CodeAnalysisExecutive::fileSLOCs(const File& file)
</pre><button class="button-expcol" onclick="showHideSection('span41')">{</button><div id="span41" style = "display: inline"><pre>
	return slocMap_[file];
</pre></div><pre>}
//----&lt report number of files processed &gt-----------------------

size_t CodeAnalysisExecutive::numFiles()
</pre><button class="button-expcol" onclick="showHideSection('span42')">{</button><div id="span42" style = "display: inline"><pre>
	return numFiles_;
</pre></div><pre>}
//----&lt report number of directories searched &gt------------------

size_t CodeAnalysisExecutive::numDirs()
</pre><button class="button-expcol" onclick="showHideSection('span43')">{</button><div id="span43" style = "display: inline"><pre>
	return numDirs_;
</pre></div><pre>}
//----&lt show processing activity &gt-------------------------------

void CodeAnalysisExecutive::showActivity(const File& file)
</pre><button class="button-expcol" onclick="showHideSection('span44')">{</button><div id="span44" style = "display: inline"><pre>
	std::function&ltstd::string(std::string, size_t)&gt trunc = [](std::string in, size_t count)
	</pre><button class="button-expcol" onclick="showHideSection('span45')">{</button><div id="span45" style = "display: inline"><pre>
		return in.substr(0, count);
	</pre></div><pre>};

	if (Rslt::running())
	</pre><button class="button-expcol" onclick="showHideSection('span46')">{</button><div id="span46" style = "display: inline"><pre>
		std::cout &lt&lt std::left &lt&lt "\r     Processing file: " &lt&lt std::setw(80) &lt&lt trunc(file, 80);
	</pre></div><pre>}
</pre></div><pre>}

void CodeAnalysisExecutive::clearActivity()
</pre><button class="button-expcol" onclick="showHideSection('span47')">{</button><div id="span47" style = "display: inline"><pre>
	if (Rslt::running())
	</pre><button class="button-expcol" onclick="showHideSection('span48')">{</button><div id="span48" style = "display: inline"><pre>
		std::cout &lt&lt std::left &lt&lt "\r                      " &lt&lt std::setw(80) &lt&lt std::string(80, ' ');
	</pre></div><pre>}
</pre></div><pre>}
//----&lt parses code and saves results in AbstrSynTree &gt--------------
/*
* - Processes C++ header files first to build AST with nodes for
*   all public classes and structs.
* - Then processes C++ implementation files.  Each member function
*   is relocated to its class scope node, not the local scope.
* - Therefore, this ordering is important.
* - C# code has all member functions inline, so we don't need to
*   do any relocation of nodes in the AST.  Therefore, that analysis
*   can be done at any time.
* - If you bore down into the analysis code in ActionsAndRules.h you
*   will find some gymnastics to handle template syntax.  That can
*   get somewhat complicated, so there may be some latent bugs there.
*   I don't know of any at this time.
*/
void CodeAnalysisExecutive::setLanguage(const File& file)
</pre><button class="button-expcol" onclick="showHideSection('span49')">{</button><div id="span49" style = "display: inline"><pre>
	std::string ext = FileSystem::Path::getExt(file);
	if (ext == "h" || ext == "cpp")
		pRepo_-&gtlanguage() = Language::Cpp;
	else if (ext == "cs")
		pRepo_-&gtlanguage() = Language::CSharp;
</pre></div><pre>}

void CodeAnalysisExecutive::processSourceCode(bool showProc)
</pre><button class="button-expcol" onclick="showHideSection('span50')">{</button><div id="span50" style = "display: inline"><pre>
	for (auto file : cppHeaderFiles())
	</pre><button class="button-expcol" onclick="showHideSection('span51')">{</button><div id="span51" style = "display: inline"><pre>
		if (showProc)
			showActivity(file);
		pRepo_-&gtpackage() = FileSystem::Path::getName(file);

		if (!configure_.Attach(file))
		</pre><button class="button-expcol" onclick="showHideSection('span52')">{</button><div id="span52" style = "display: inline"><pre>
			std::ostringstream out;
			out &lt&lt "\n  could not open file " &lt&lt file &lt&lt "\n";
			Rslt::write(out.str());
			Rslt::flush();
			continue;
		</pre></div><pre>}
		// parse file
		Rslt::flush();
		Demo::flush();
		Dbug::flush();

		if (!Rslt::running())
			Demo::write("\n\n  opening file \"" + pRepo_-&gtpackage() + "\"");
		if (!Demo::running() && !Rslt::running())
			Dbug::write("\n\n  opening file \"" + pRepo_-&gtpackage() + "\"");
		pRepo_-&gtlanguage() = Language::Cpp;
		pRepo_-&gtcurrentPath() = file;
		while (pParser_-&gtnext())
		</pre><button class="button-expcol" onclick="showHideSection('span53')">{</button><div id="span53" style = "display: inline"><pre>
			pParser_-&gtparse();
		</pre></div><pre>}

		Slocs slocs = pRepo_-&gtToker()-&gtcurrentLineCount();
		slocMap_[pRepo_-&gtpackage()] = slocs;
	</pre></div><pre>}
	for (auto file : cppImplemFiles())
	</pre><button class="button-expcol" onclick="showHideSection('span54')">{</button><div id="span54" style = "display: inline"><pre>
		if (showProc)
			showActivity(file);
		pRepo_-&gtpackage() = FileSystem::Path::getName(file);

		if (!configure_.Attach(file))
		</pre><button class="button-expcol" onclick="showHideSection('span55')">{</button><div id="span55" style = "display: inline"><pre>
			std::ostringstream out;
			out &lt&lt "\n  could not open file " &lt&lt file &lt&lt "\n";
			Rslt::write(out.str());
			Rslt::flush();
			continue;
		</pre></div><pre>}
		// parse file

		if (!Rslt::running())
			Demo::write("\n\n  opening file \"" + pRepo_-&gtpackage() + "\"");
		if (!Demo::running() && !Rslt::running())
			Dbug::write("\n\n  opening file \"" + pRepo_-&gtpackage() + "\"");
		pRepo_-&gtlanguage() = Language::Cpp;
		pRepo_-&gtcurrentPath() = file;
		while (pParser_-&gtnext())
			pParser_-&gtparse();

		Slocs slocs = pRepo_-&gtToker()-&gtcurrentLineCount();
		slocMap_[pRepo_-&gtpackage()] = slocs;
	</pre></div><pre>}
	for (auto file : csharpFiles())
	</pre><button class="button-expcol" onclick="showHideSection('span56')">{</button><div id="span56" style = "display: inline"><pre>
		if (showProc)
			showActivity(file);
		pRepo_-&gtpackage() = FileSystem::Path::getName(file);

		if (!configure_.Attach(file))
		</pre><button class="button-expcol" onclick="showHideSection('span57')">{</button><div id="span57" style = "display: inline"><pre>
			std::ostringstream out;
			out &lt&lt "\n  could not open file " &lt&lt file &lt&lt "\n";
			Rslt::write(out.str());
			continue;
		</pre></div><pre>}
		// parse file

		if (!Rslt::running())
			Demo::write("\n\n  opening file \"" + pRepo_-&gtpackage() + "\"");
		if (!Demo::running() && !Rslt::running())
			Dbug::write("\n\n  opening file \"" + pRepo_-&gtpackage() + "\"");
		pRepo_-&gtlanguage() = Language::CSharp;
		pRepo_-&gtcurrentPath() = file;
		while (pParser_-&gtnext())
			pParser_-&gtparse();

		Slocs slocs = pRepo_-&gtToker()-&gtcurrentLineCount();
		slocMap_[pRepo_-&gtpackage()] = slocs;
	</pre></div><pre>}
	if (showProc)
		clearActivity();
	std::ostringstream out;
	out &lt&lt std::left &lt&lt "\r  " &lt&lt std::setw(77) &lt&lt " ";
	Rslt::write(out.str());
</pre></div><pre>}
//----&lt evaluate complexities of each AST node &gt---------------------

void CodeAnalysisExecutive::complexityAnalysis()
</pre><button class="button-expcol" onclick="showHideSection('span58')">{</button><div id="span58" style = "display: inline"><pre>
	ASTNode* pGlobalScope = pRepo_-&gtgetGlobalScope();
	CodeAnalysis::complexityEval(pGlobalScope);
</pre></div><pre>}
//----&lt comparison functor for sorting FileToNodeCollection &gt----
/*
* - supports stable sort on extension values
* - displayMetrics(...) uses to organize metrics display
*/
struct CompExts
</pre><button class="button-expcol" onclick="showHideSection('span59')">{</button><div id="span59" style = "display: inline"><pre>
	bool operator()(const std::pair&ltFile, ASTNode*&gt& first, const std::pair&ltFile, ASTNode*&gt& second)
	</pre><button class="button-expcol" onclick="showHideSection('span60')">{</button><div id="span60" style = "display: inline"><pre>
		return FileSystem::Path::getExt(first.first) &gt FileSystem::Path::getExt(second.first);
	</pre></div><pre>}
</pre></div><pre>};
//----&lt comparison functor for sorting FileToNodeCollection &gt----
/*
* - supports stable sort on name values
* - displayMetrics(...) uses these functions to organize metrics display
*/
static void removeExt(std::string& name)
</pre><button class="button-expcol" onclick="showHideSection('span61')">{</button><div id="span61" style = "display: inline"><pre>
	size_t extStartIndex = name.find_last_of('.');
	name = name.substr(0, extStartIndex);
</pre></div><pre>}

struct CompNames
</pre><button class="button-expcol" onclick="showHideSection('span62')">{</button><div id="span62" style = "display: inline"><pre>
	bool operator()(const std::pair&ltFile, ASTNode*&gt& first, const std::pair&ltFile, ASTNode*&gt& second)
	</pre><button class="button-expcol" onclick="showHideSection('span63')">{</button><div id="span63" style = "display: inline"><pre>
		std::string fnm = FileSystem::Path::getName(first.first);
		removeExt(fnm);
		std::string snm = FileSystem::Path::getName(second.first);
		removeExt(snm);
		return fnm &lt snm;
	</pre></div><pre>}
</pre></div><pre>};
//----&lt display header line for displayMmetrics() &gt------------------

void CodeAnalysisExecutive::displayHeader()
</pre><button class="button-expcol" onclick="showHideSection('span64')">{</button><div id="span64" style = "display: inline"><pre>
	std::ostringstream out;
	out &lt&lt std::right;
	out &lt&lt "\n ";
	out &lt&lt std::setw(25) &lt&lt "file name";
	out &lt&lt std::setw(12) &lt&lt "type";
	out &lt&lt std::setw(35) &lt&lt "name";
	out &lt&lt std::setw(8) &lt&lt "line";
	out &lt&lt std::setw(8) &lt&lt "size";
	out &lt&lt std::setw(8) &lt&lt "cplx";
	out &lt&lt std::right;
	out &lt&lt "\n  ";
	out &lt&lt std::setw(25) &lt&lt "-----------------------";
	out &lt&lt std::setw(12) &lt&lt "----------";
	out &lt&lt std::setw(35) &lt&lt "---------------------------------";
	out &lt&lt std::setw(8) &lt&lt "------";
	out &lt&lt std::setw(8) &lt&lt "------";
	out &lt&lt std::setw(8) &lt&lt "------";
	Rslt::write(out.str());
</pre></div><pre>}
//----&lt display single line for displayMetrics() &gt-------------------

void CodeAnalysisExecutive::displayMetricsLine(const File& file, ASTNode* pNode)
</pre><button class="button-expcol" onclick="showHideSection('span65')">{</button><div id="span65" style = "display: inline"><pre>
	std::function&ltstd::string(std::string, size_t)&gt trunc = [](std::string in, size_t count)
	</pre><button class="button-expcol" onclick="showHideSection('span66')">{</button><div id="span66" style = "display: inline"><pre>
		return in.substr(0, count);
	</pre></div><pre>};
	std::ostringstream out;
	out &lt&lt std::right;
	out &lt&lt "\n ";
	out &lt&lt std::setw(25) &lt&lt trunc(file, 23);
	out &lt&lt std::setw(12) &lt&lt pNode-&gttype_;
	out &lt&lt std::setw(35) &lt&lt trunc(pNode-&gtname_, 33);
	out &lt&lt std::setw(8) &lt&lt pNode-&gtstartLineCount_;
	out &lt&lt std::setw(8) &lt&lt pNode-&gtendLineCount_ - pNode-&gtstartLineCount_ + 1;
	size_t debug1 = pNode-&gtstartLineCount_;
	size_t debug2 = pNode-&gtendLineCount_;
	out &lt&lt std::setw(8) &lt&lt pNode-&gtcomplexity_;
	Rslt::write(out.str());
</pre></div><pre>}
//----&lt display lines containing public data declaration &gt-----------

std::string CodeAnalysisExecutive::showData(const Scanner::ITokCollection* pTc)
</pre><button class="button-expcol" onclick="showHideSection('span67')">{</button><div id="span67" style = "display: inline"><pre>
	std::string semiExpStr;
	for (size_t i = 0; i &lt pTc-&gtlength(); ++i)
		semiExpStr += (*pTc)[i] + " ";
	return semiExpStr;
</pre></div><pre>}

void CodeAnalysisExecutive::displayDataLines(ASTNode* pNode, bool isSummary)
</pre><button class="button-expcol" onclick="showHideSection('span68')">{</button><div id="span68" style = "display: inline"><pre>
	for (auto datum : pNode-&gtdecl_)
	</pre><button class="button-expcol" onclick="showHideSection('span69')">{</button><div id="span69" style = "display: inline"><pre>
		if (pNode-&gtparentType_ == "namespace" || pNode-&gtparentType_ == "class" || pNode-&gtparentType_ == "struct")
		</pre><button class="button-expcol" onclick="showHideSection('span70')">{</button><div id="span70" style = "display: inline"><pre>
			if (pNode-&gttype_ == "function" || pNode-&gtparentType_ == "function")
				continue;
			if (datum.access_ == Access::publ && datum.declType_ == DeclType::dataDecl)
			</pre><button class="button-expcol" onclick="showHideSection('span71')">{</button><div id="span71" style = "display: inline"><pre>
				std::ostringstream out;
				out &lt&lt std::right;
				out &lt&lt "\n ";
				out &lt&lt std::setw(25) &lt&lt "public data:" &lt&lt " ";
				if (isSummary)
				</pre><button class="button-expcol" onclick="showHideSection('span72')">{</button><div id="span72" style = "display: inline"><pre>
					out &lt&lt datum.package_ &lt&lt " : " &lt&lt datum.line_ &lt&lt " - "
						&lt&lt pNode-&gttype_ &lt&lt " " &lt&lt pNode-&gtname_ &lt&lt "\n " &lt&lt std::setw(15) &lt&lt " ";
				</pre></div><pre>}
				out &lt&lt showData(datum.pTc);
				Rslt::write(out.str());
			</pre></div><pre>}
		</pre></div><pre>}
	</pre></div><pre>}
</pre></div><pre>}
//----&lt  helper for displayMetrics() &gt-------------------------------
/*
* - Breaking this out as a separate function allows application to
*   display metrics for a subset of the Abstract Syntax Tree
*/
void CodeAnalysisExecutive::displayMetrics(ASTNode* root)
</pre><button class="button-expcol" onclick="showHideSection('span73')">{</button><div id="span73" style = "display: inline"><pre>
	flushLogger();
	std::ostringstream out;
	out &lt&lt "Code Metrics - Start Line, Size (lines/code), and Complexity (number of scopes)";
	Utils::sTitle(out.str(), 3, 92, out, '=');
	out &lt&lt "\n";
	Rslt::write(out.str());

	std::function&ltvoid(ASTNode* pNode)&gt co = [&](ASTNode* pNode) </pre><button class="button-expcol" onclick="showHideSection('span74')">{</button><div id="span74" style = "display: inline"><pre>
		if (
			pNode-&gttype_ == "namespace" ||
			pNode-&gttype_ == "function" ||
			pNode-&gttype_ == "class" ||
			pNode-&gttype_ == "interface" ||
			pNode-&gttype_ == "struct" ||
			pNode-&gttype_ == "lambda"
			)
			fileNodes_.push_back(std::pair&ltFile, ASTNode*&gt(pNode-&gtpackage_, pNode));
	</pre></div><pre>};
	ASTWalkNoIndent(root, co);
	std::stable_sort(fileNodes_.begin(), fileNodes_.end(), CompExts());
	std::stable_sort(fileNodes_.begin(), fileNodes_.end(), CompNames());

	displayHeader();

	std::string prevFile;
	for (auto item : fileNodes_)
	</pre><button class="button-expcol" onclick="showHideSection('span75')">{</button><div id="span75" style = "display: inline"><pre>
		if (item.first != prevFile)
		</pre><button class="button-expcol" onclick="showHideSection('span76')">{</button><div id="span76" style = "display: inline"><pre>
			Rslt::write("\n");
			displayHeader();
		</pre></div><pre>}
		displayMetricsLine(item.first, item.second);
		displayDataLines(item.second);
		prevFile = item.first;
	</pre></div><pre>}
	Rslt::write("\n");
</pre></div><pre>}
//----&lt display metrics results of code analysis &gt---------------

void CodeAnalysisExecutive::displayMetrics()
</pre><button class="button-expcol" onclick="showHideSection('span77')">{</button><div id="span77" style = "display: inline"><pre>
	ASTNode* pGlobalScope = pRepo_-&gtgetGlobalScope();
	displayMetrics(pGlobalScope);
</pre></div><pre>}
//----&lt walk tree of element nodes &gt---------------------------------

template&lttypename element&gt
void TreeWalk(element* pItem, bool details = false)
</pre><button class="button-expcol" onclick="showHideSection('span78')">{</button><div id="span78" style = "display: inline"><pre>
	static std::string path;
	if (path != pItem-&gtpath_ && details == true)
	</pre><button class="button-expcol" onclick="showHideSection('span79')">{</button><div id="span79" style = "display: inline"><pre>
		path = pItem-&gtpath_;
		Rslt::write("\n" + path);
	</pre></div><pre>}
	static size_t indentLevel = 0;
	std::ostringstream out;
	out &lt&lt "\n  " &lt&lt std::string(2 * indentLevel, ' ') &lt&lt pItem-&gtshow();
	Rslt::write(out.str());
	auto iter = pItem-&gtchildren_.begin();
	++indentLevel;
	while (iter != pItem-&gtchildren_.end())
	</pre><button class="button-expcol" onclick="showHideSection('span80')">{</button><div id="span80" style = "display: inline"><pre>
		TreeWalk(*iter);
		++iter;
	</pre></div><pre>}
	--indentLevel;
</pre></div><pre>}
//----&lt display the AbstrSynTree build in processSourceCode() &gt------

void CodeAnalysisExecutive::displayAST()
</pre><button class="button-expcol" onclick="showHideSection('span81')">{</button><div id="span81" style = "display: inline"><pre>
	flushLogger();
	ASTNode* pGlobalScope = pRepo_-&gtgetGlobalScope();
	Utils::title("Abstract Syntax Tree");
	TreeWalk(pGlobalScope);
	Rslt::write("\n");
</pre></div><pre>}
//----&lt show functions with metrics exceeding specified limits &gt-----

void CodeAnalysisExecutive::displayMetricSummary(size_t sMax, size_t cMax)
</pre><button class="button-expcol" onclick="showHideSection('span82')">{</button><div id="span82" style = "display: inline"><pre>
	flushLogger();
	std::ostringstream out;
	Utils::sTitle("Functions Exceeding Metric Limits and Public Data", 3, 92, out, '=');
	Rslt::write(out.str());
	displayHeader();

	if (fileNodes_.size() == 0)  // only build fileNodes_ if displayMetrics hasn't been called
	</pre><button class="button-expcol" onclick="showHideSection('span83')">{</button><div id="span83" style = "display: inline"><pre>
		std::function&ltvoid(ASTNode* pNode)&gt co = [&](ASTNode* pNode) </pre><button class="button-expcol" onclick="showHideSection('span84')">{</button><div id="span84" style = "display: inline"><pre>
			fileNodes_.push_back(std::pair&ltFile, ASTNode*&gt(pNode-&gtpackage_, pNode));
		</pre></div><pre>};
		ASTNode* pGlobalNamespace = pRepo_-&gtgetGlobalScope();
		ASTWalkNoIndent(pGlobalNamespace, co);
		std::stable_sort(fileNodes_.begin(), fileNodes_.end(), CompExts());
		std::stable_sort(fileNodes_.begin(), fileNodes_.end(), CompNames());
	</pre></div><pre>}
	for (auto item : fileNodes_)
	</pre><button class="button-expcol" onclick="showHideSection('span85')">{</button><div id="span85" style = "display: inline"><pre>
		if (item.second-&gttype_ == "function")
		</pre><button class="button-expcol" onclick="showHideSection('span86')">{</button><div id="span86" style = "display: inline"><pre>
			size_t size = item.second-&gtendLineCount_ - item.second-&gtstartLineCount_ + 1;
			size_t cmpl = item.second-&gtcomplexity_;
			if (size &gt sMax || cmpl &gt cMax)
				displayMetricsLine(item.first, item.second);
		</pre></div><pre>}
	</pre></div><pre>}
	Rslt::write("\n");
	for (auto item : fileNodes_)
	</pre><button class="button-expcol" onclick="showHideSection('span87')">{</button><div id="span87" style = "display: inline"><pre>
		displayDataLines(item.second, true);
	</pre></div><pre>}
	Rslt::write("\n");
</pre></div><pre>}
//----&lt comparison functor for sorting SLOC display &gt----------------

struct compFiles
</pre><button class="button-expcol" onclick="showHideSection('span88')">{</button><div id="span88" style = "display: inline"><pre>
private:
	std::string ChangeFirstCharOfExt(const std::string& fileName) const
	</pre><button class="button-expcol" onclick="showHideSection('span89')">{</button><div id="span89" style = "display: inline"><pre>
		std::string temp = fileName;
		size_t pos = temp.find_last_of('.');
		if (pos &lt temp.size() - 1)
			if (temp[pos + 1] == 'h')
				temp[pos + 1] = 'a';
		return temp;
	</pre></div><pre>}
public:
	bool operator()(const std::string& fileName1, const std::string& fileName2) const
	</pre><button class="button-expcol" onclick="showHideSection('span90')">{</button><div id="span90" style = "display: inline"><pre>
		return ChangeFirstCharOfExt(fileName1) &lt ChangeFirstCharOfExt(fileName2);
	</pre></div><pre>}
</pre></div><pre>};
//----&lt show sizes of all the files processed &gt----------------------

void CodeAnalysisExecutive::displaySlocs()
</pre><button class="button-expcol" onclick="showHideSection('span91')">{</button><div id="span91" style = "display: inline"><pre>
	flushLogger();
	Utils::sTitle("File Size - Source Lines of Code", 3, 92);
	size_t slocCount = 0;
	std::map&ltstd::string, size_t, compFiles&gt fileColl;
	for (auto item : fileMap_)
	</pre><button class="button-expcol" onclick="showHideSection('span92')">{</button><div id="span92" style = "display: inline"><pre>
		for (auto file : item.second)
		</pre><button class="button-expcol" onclick="showHideSection('span93')">{</button><div id="span93" style = "display: inline"><pre>
			File fileName = FileSystem::Path::getName(file);
			fileColl[file] = slocMap_[fileName];
		</pre></div><pre>}
	</pre></div><pre>}
	for (auto fitem : fileColl)
	</pre><button class="button-expcol" onclick="showHideSection('span94')">{</button><div id="span94" style = "display: inline"><pre>
		std::ostringstream out;
		out &lt&lt "\n  " &lt&lt std::setw(8) &lt&lt fitem.second &lt&lt " : " &lt&lt fitem.first;
		Rslt::write(out.str());
		slocCount += fitem.second;
	</pre></div><pre>}
	std::ostringstream out;
	out &lt&lt "\n\n      Total line count = " &lt&lt slocCount &lt&lt "\n";
	Rslt::write(out.str());
	Rslt::write("\n");
</pre></div><pre>}
//----&lt display analysis info based on command line options &gt--------

void CodeAnalysisExecutive::dispatchOptionalDisplays()
</pre><button class="button-expcol" onclick="showHideSection('span95')">{</button><div id="span95" style = "display: inline"><pre>
	for (auto opt : options_)
	</pre><button class="button-expcol" onclick="showHideSection('span96')">{</button><div id="span96" style = "display: inline"><pre>
		switch (opt)
		</pre><button class="button-expcol" onclick="showHideSection('span97')">{</button><div id="span97" style = "display: inline"><pre>
		case 'm':
			displayMetrics();
			Rslt::start();
			break;
		case 'a':
			displayAST();
			Rslt::start();
			break;
		case 's':
			displaySlocs();
			Rslt::start();
			break;
		default:
			break;
		</pre></div><pre>}
	</pre></div><pre>}
</pre></div><pre>}
//----&lt display analysis info based on command line options &gt--------

class PortToTableLambda
</pre><button class="button-expcol" onclick="showHideSection('span98')">{</button><div id="span98" style = "display: inline"><pre>
	void operator ()(ASTNode * node, int dbIndex)
	</pre><button class="button-expcol" onclick="showHideSection('span99')">{</button><div id="span99" style = "display: inline"><pre>

	</pre></div><pre>}
</pre></div><pre>};


void CodeAnalysisExecutive::setDisplayModes()
</pre><button class="button-expcol" onclick="showHideSection('span100')">{</button><div id="span100" style = "display: inline"><pre>
	for (auto opt : options_)
	</pre><button class="button-expcol" onclick="showHideSection('span101')">{</button><div id="span101" style = "display: inline"><pre>
		switch (opt)
		</pre><button class="button-expcol" onclick="showHideSection('span102')">{</button><div id="span102" style = "display: inline"><pre>
		case 'r':
			Rslt::start();
			break;
		case 'd':
			Demo::start();
			break;
		case 'b':
			Dbug::start();
			break;
		case 'f':
			setLogFile("logFile.txt");
			break;
		default:
			if (opt != 'a' && opt != 'b' && opt != 'd' && opt != 'f' && opt != 'm' && opt != 'r' && opt != 's')
			</pre><button class="button-expcol" onclick="showHideSection('span103')">{</button><div id="span103" style = "display: inline"><pre>
				std::cout &lt&lt "\n\n  unknown option " &lt&lt opt &lt&lt "\n\n";
			</pre></div><pre>}
		</pre></div><pre>}
	</pre></div><pre>}
</pre></div><pre>}
//----&lt helper functions for managing application's logging &gt--------

void CodeAnalysisExecutive::startLogger(std::ostream& out)
</pre><button class="button-expcol" onclick="showHideSection('span104')">{</button><div id="span104" style = "display: inline"><pre>
	Rslt::attach(&out);
	Demo::attach(&out);
	Dbug::attach(&out);

	// will start Demo and Dbug if  have options /d and /b

	setDisplayModes();
</pre></div><pre>}

void CodeAnalysisExecutive::flushLogger()
</pre><button class="button-expcol" onclick="showHideSection('span105')">{</button><div id="span105" style = "display: inline"><pre>
	Rslt::flush();
	Demo::flush();
	Dbug::flush();
</pre></div><pre>}

void CodeAnalysisExecutive::stopLogger()
</pre><button class="button-expcol" onclick="showHideSection('span106')">{</button><div id="span106" style = "display: inline"><pre>
	Rslt::flush();
	Demo::flush();
	Dbug::flush();
	Rslt::stop();
	Demo::stop();
	Dbug::stop();
</pre></div><pre>}
//----&lt open file stream for logging &gt-------------------------------
/*
*  - must come after CodeAnalysisExecutive::processCommandLine()
*  - must come before starting any of the loggers
*/
void CodeAnalysisExecutive::setLogFile(const File& file)
</pre><button class="button-expcol" onclick="showHideSection('span107')">{</button><div id="span107" style = "display: inline"><pre>
	std::string path = getAnalysisPath();
	path += "\\" + file;
	pLogStrm_ = new std::ofstream(path);
	if (pLogStrm_-&gtgood())
	</pre><button class="button-expcol" onclick="showHideSection('span108')">{</button><div id="span108" style = "display: inline"><pre>
		Rslt::attach(pLogStrm_);
		Demo::attach(pLogStrm_);
		Dbug::attach(pLogStrm_);
	</pre></div><pre>}
	else
		Rslt::write("\n  couldn't open logFile.txt for writing");
</pre></div><pre>}

std::string CodeAnalysisExecutive::systemTime()
</pre><button class="button-expcol" onclick="showHideSection('span109')">{</button><div id="span109" style = "display: inline"><pre>
	time_t sysTime = time(&sysTime);
	char buffer[27];
	ctime_s(buffer, 27, &sysTime);
	buffer[24] = '\0';
	std::string temp(buffer);
	return temp;
</pre></div><pre>}
//----&lt conduct code analysis &gt--------------------------------------

#include &ltfstream&gt

int main(int argc, char* argv[])
</pre><button class="button-expcol" onclick="showHideSection('span110')">{</button><div id="span110" style = "display: inline"><pre>
	using namespace CodeAnalysis;

	DependencyAnalysisEngine dep;
	auto dependencies = dep.readAnalysisResultFromFile("output.txt");

	TestExecutive te;
	te.demoAllReqs();

	CodeAnalysisExecutive exec;

	try </pre><button class="button-expcol" onclick="showHideSection('span111')">{</button><div id="span111" style = "display: inline"><pre>
		bool succeeded = exec.ProcessCommandLine(argc, argv);
		if (!succeeded)
		</pre><button class="button-expcol" onclick="showHideSection('span112')">{</button><div id="span112" style = "display: inline"><pre>
			return 1;
		</pre></div><pre>}
		exec.setDisplayModes();
		exec.startLogger(std::cout);

		std::ostringstream tOut("CodeAnalysis - Version 1.5");
		Utils::sTitle(tOut.str(), 3, 92, tOut, '=');
		Rslt::write(tOut.str());

		//Rslt::write("\n     " + exec.getAnalysisPath());
		Rslt::write("\n     " + exec.systemTime());
		Rslt::flush();
		exec.showCommandLineArguments(argc, argv);
		Rslt::write("\n");

		exec.getSourceFiles();
		exec.processSourceCode(true);
		//exec.startDependencyAnalysis();
		exec.complexityAnalysis();
		exec.dispatchOptionalDisplays();
		exec.flushLogger();
		exec.displayMetricSummary(50, 10);

		exec.flushLogger();
		Rslt::write("\n");
		std::ostringstream out;
		out &lt&lt "\n  " &lt&lt std::setw(10) &lt&lt "searched" &lt&lt std::setw(6) &lt&lt exec.numDirs() &lt&lt " dirs";
		out &lt&lt "\n  " &lt&lt std::setw(10) &lt&lt "processed" &lt&lt std::setw(6) &lt&lt exec.numFiles() &lt&lt " files";
		Rslt::write(out.str());
		Rslt::write("\n");
		exec.stopLogger();
		std::cout &lt&lt "\n  Code Analysis completed";

		TypeAnal typeAnalyzer;
		typeAnalyzer.doTypeAnal(exec.getAnalysisPath());
		TypeTable typetable = typeAnalyzer.exportTypeTable();

		DependencyAnalysisEngine engine;
		engine.importTypeTable(typetable);
		engine.startDependencyAnalysis(exec.getAnalysisPath().c_str());
		engine.exportAnalysisResultToFile(exec.getXMLPath(), exec.getAnalysisPath());

		Display displayModule;
		displayModule.displayAnalysisResult(engine.exportAnalysisResult());

		getchar();
	</pre></div><pre>}
	catch (std::exception& except)
	</pre><button class="button-expcol" onclick="showHideSection('span113')">{</button><div id="span113" style = "display: inline"><pre>
		exec.flushLogger();
		std::cout &lt&lt "\n\n  caught exception in Executive::main: " + std::string(except.what()) + "\n\n";
		exec.stopLogger();
		return 1;
	</pre></div><pre>}
	return 0;
</pre></div><pre>}</pre>
<hr>
</body>
</html>
